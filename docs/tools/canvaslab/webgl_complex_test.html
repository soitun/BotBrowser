<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>WebGL Complex E2E Test - BotCanvas Recording</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; background: #f5f5f5; }
    h1 { font-size: 1.4rem; }
    canvas { border: 1px solid #ccc; display: block; margin: 12px 0; background: #fff; }
    pre { background: #222; color: #ddd; padding: 12px; border-radius: 6px; font-size: 13px; max-height: 400px; overflow: auto; }
    .note { color: #666; font-size: 13px; margin-bottom: 16px; }
  </style>
</head>
<body>
  <h1>WebGL Complex E2E Test for JSONL Recording</h1>
  <p class="note">Load with <code>--bot-canvas-record-file=/tmp/webgl_e2e.jsonl</code></p>

  <!-- Canvas 1: WebGL2 Full Pipeline -->
  <canvas id="c1" width="256" height="256"></canvas>
  <!-- Canvas 2: WebGL1 Basic -->
  <canvas id="c2" width="128" height="128"></canvas>
  <!-- Canvas 3: 2D for comparison -->
  <canvas id="c3" width="200" height="100"></canvas>
  <pre id="log"></pre>

  <script>
    const logEl = document.getElementById('log');
    const log = (msg) => { logEl.textContent += msg + '\n'; console.log(msg); };

    // ===================== Canvas 1: WebGL2 Full Pipeline =====================
    (() => {
      log('=== Canvas 1: WebGL2 Full Pipeline ===');
      const canvas = document.getElementById('c1');
      const gl = canvas.getContext('webgl2', {
        alpha: true,
        antialias: true,
        depth: true,
        stencil: true,
        premultipliedAlpha: false,
        preserveDrawingBuffer: true
      });
      if (!gl) { log('WebGL2 not supported'); return; }
      log('WebGL2 context created');

      // --- Shader creation ---
      const vsSource = `#version 300 es
        layout(location = 0) in vec2 a_position;
        layout(location = 1) in vec3 a_color;
        layout(location = 2) in vec2 a_texcoord;
        uniform mat4 u_matrix;
        uniform float u_pointSize;
        out vec3 v_color;
        out vec2 v_texcoord;
        void main() {
          gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);
          gl_PointSize = u_pointSize;
          v_color = a_color;
          v_texcoord = a_texcoord;
        }`;
      const fsSource = `#version 300 es
        precision highp float;
        in vec3 v_color;
        in vec2 v_texcoord;
        uniform sampler2D u_texture;
        uniform vec4 u_tint;
        out vec4 fragColor;
        void main() {
          vec4 texColor = texture(u_texture, v_texcoord);
          fragColor = vec4(v_color, 1.0) * texColor * u_tint;
        }`;

      function createShader(type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          log('Shader error: ' + gl.getShaderInfoLog(s));
        }
        return s;
      }

      const vs = createShader(gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
      log('Shaders compiled');

      // --- Program ---
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.validateProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        log('Link error: ' + gl.getProgramInfoLog(prog));
      }
      gl.useProgram(prog);
      log('Program linked & active');

      // --- Uniform locations ---
      const uMatrix = gl.getUniformLocation(prog, 'u_matrix');
      const uPointSize = gl.getUniformLocation(prog, 'u_pointSize');
      const uTexture = gl.getUniformLocation(prog, 'u_texture');
      const uTint = gl.getUniformLocation(prog, 'u_tint');
      log('Uniform locations obtained');

      // --- Attrib locations ---
      const aPos = gl.getAttribLocation(prog, 'a_position');
      const aCol = gl.getAttribLocation(prog, 'a_color');
      const aTex = gl.getAttribLocation(prog, 'a_texcoord');
      log(`Attrib locations: pos=${aPos}, col=${aCol}, tex=${aTex}`);

      // --- VAO + Buffers ---
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      // Interleaved VBO: pos(2f) + color(3f) + texcoord(2f) = 28 bytes/vertex
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // pos        color       texcoord
         0.0,  0.5,  1, 0, 0,   0.5, 1.0,  // top
        -0.5, -0.5,  0, 1, 0,   0.0, 0.0,  // bottom-left
         0.5, -0.5,  0, 0, 1,   1.0, 0.0,  // bottom-right
         0.5,  0.5,  1, 1, 0,   1.0, 1.0,  // top-right (for quad)
      ]), gl.STATIC_DRAW);

      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 28, 0);
      gl.enableVertexAttribArray(aCol);
      gl.vertexAttribPointer(aCol, 3, gl.FLOAT, false, 28, 8);
      gl.enableVertexAttribArray(aTex);
      gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 28, 20);
      log('VBO + attribs configured');

      // --- Index Buffer (for drawElements) ---
      const ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([
        0, 1, 2,  // triangle 1
        0, 2, 3,  // triangle 2
      ]), gl.STATIC_DRAW);
      log('IBO configured');

      // --- Texture ---
      const tex = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex);

      // 4x4 checkerboard
      const texData = new Uint8Array(4 * 4 * 4);
      for (let i = 0; i < 16; i++) {
        const c = ((i % 4) + Math.floor(i / 4)) % 2 === 0 ? 255 : 128;
        texData.set([c, c, c, 255], i * 4);
      }
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4, 4, 0, gl.RGBA, gl.UNSIGNED_BYTE, texData);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.generateMipmap(gl.TEXTURE_2D);
      log('Texture created');

      // --- Second texture ---
      const tex2 = gl.createTexture();
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, tex2);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE,
        new Uint8Array([255,0,0,255, 0,255,0,255, 0,0,255,255, 255,255,0,255]));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      log('Texture 2 created');

      // --- Framebuffer + Renderbuffer ---
      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

      const rbo = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH24_STENCIL8, 256, 256);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, rbo);

      // Attach texture to FBO
      const fboTex = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fboTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fboTex, 0);

      const fboStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      log(`FBO status: ${fboStatus === gl.FRAMEBUFFER_COMPLETE ? 'COMPLETE' : fboStatus}`);

      // Unbind FBO - draw to default
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      log('FBO + RBO configured');

      // --- Uniforms ---
      // Identity matrix
      gl.uniformMatrix4fv(uMatrix, false, new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1,
      ]));
      gl.uniform1f(uPointSize, 4.0);
      gl.uniform1i(uTexture, 0);
      gl.uniform4f(uTint, 1.0, 1.0, 1.0, 1.0);
      log('Uniforms set');

      // --- State ---
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.blendEquation(gl.FUNC_ADD);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.depthMask(true);
      gl.enable(gl.STENCIL_TEST);
      gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
      gl.colorMask(true, true, true, true);
      gl.viewport(0, 0, 256, 256);
      gl.scissor(0, 0, 256, 256);
      gl.enable(gl.SCISSOR_TEST);
      gl.clearColor(0.05, 0.05, 0.1, 1.0);
      gl.clearDepth(1.0);
      gl.clearStencil(0);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      gl.lineWidth(2.0);
      log('State configured');

      // --- Draw triangle with drawArrays ---
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      log('drawArrays done');

      // --- Draw quad with drawElements ---
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      log('drawElements done');

      // --- Draw points ---
      gl.drawArrays(gl.POINTS, 0, 4);
      log('drawArrays POINTS done');

      // --- Draw to FBO ---
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fbo);
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      log('FBO draw done');

      // --- Flush ---
      gl.flush();
      log('flush done');

      // --- Reads ---
      // readPixels
      const px = new Uint8Array(4);
      gl.readPixels(128, 128, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
      log(`readPixels center: [${px.join(', ')}]`);

      // Larger readPixels
      const px4 = new Uint8Array(4 * 4 * 4);
      gl.readPixels(0, 0, 4, 4, gl.RGBA, gl.UNSIGNED_BYTE, px4);
      log(`readPixels 4x4: first pixel [${px4[0]}, ${px4[1]}, ${px4[2]}, ${px4[3]}]`);

      // getParameter - various
      log(`RENDERER: ${gl.getParameter(gl.RENDERER)}`);
      log(`VENDOR: ${gl.getParameter(gl.VENDOR)}`);
      log(`VERSION: ${gl.getParameter(gl.VERSION)}`);
      log(`SHADING_LANGUAGE_VERSION: ${gl.getParameter(gl.SHADING_LANGUAGE_VERSION)}`);
      log(`MAX_TEXTURE_SIZE: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
      log(`MAX_RENDERBUFFER_SIZE: ${gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)}`);
      log(`MAX_VIEWPORT_DIMS: ${gl.getParameter(gl.MAX_VIEWPORT_DIMS)}`);
      log(`MAX_VERTEX_ATTRIBS: ${gl.getParameter(gl.MAX_VERTEX_ATTRIBS)}`);
      log(`MAX_COMBINED_TEXTURE_IMAGE_UNITS: ${gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)}`);
      log(`ALIASED_LINE_WIDTH_RANGE: ${gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE)}`);
      log(`ALIASED_POINT_SIZE_RANGE: ${gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE)}`);

      // Extension-based getParameter
      const ext = gl.getExtension('WEBGL_debug_renderer_info');
      if (ext) {
        log(`UNMASKED_VENDOR: ${gl.getParameter(ext.UNMASKED_VENDOR_WEBGL)}`);
        log(`UNMASKED_RENDERER: ${gl.getParameter(ext.UNMASKED_RENDERER_WEBGL)}`);
      } else {
        // Still try the raw enum values
        try { log(`UNMASKED_VENDOR (raw): ${gl.getParameter(37445)}`); } catch(e) { log('UNMASKED_VENDOR: n/a'); }
        try { log(`UNMASKED_RENDERER (raw): ${gl.getParameter(37446)}`); } catch(e) { log('UNMASKED_RENDERER: n/a'); }
      }

      // EXT_texture_filter_anisotropic
      const anisoExt = gl.getExtension('EXT_texture_filter_anisotropic');
      if (anisoExt) {
        log(`MAX_ANISOTROPY: ${gl.getParameter(anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}`);
      }

      // Shader precision format
      const spfVH = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
      log(`Vertex HIGH_FLOAT: range=[${spfVH.rangeMin},${spfVH.rangeMax}] precision=${spfVH.precision}`);
      const spfFM = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
      log(`Fragment MEDIUM_FLOAT: range=[${spfFM.rangeMin},${spfFM.rangeMax}] precision=${spfFM.precision}`);
      const spfFL = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT);
      log(`Fragment LOW_INT: range=[${spfFL.rangeMin},${spfFL.rangeMax}] precision=${spfFL.precision}`);

      // getSupportedExtensions
      const exts = gl.getSupportedExtensions();
      log(`Extensions: ${exts.length} found`);

      // getContextAttributes
      const attrs = gl.getContextAttributes();
      log(`Context attrs: ${JSON.stringify(attrs)}`);

      // isContextLost
      log(`isContextLost: ${gl.isContextLost()}`);

      // getActiveAttrib / getActiveUniform
      const activeAttrib = gl.getActiveAttrib(prog, 0);
      log(`Active attrib 0: name=${activeAttrib.name} type=${activeAttrib.type} size=${activeAttrib.size}`);
      const activeUniform = gl.getActiveUniform(prog, 0);
      log(`Active uniform 0: name=${activeUniform.name} type=${activeUniform.type} size=${activeUniform.size}`);

      // toDataURL on WebGL canvas
      const dataUrl = canvas.toDataURL('image/png');
      log(`toDataURL length: ${dataUrl.length}`);

      // --- Cleanup ---
      gl.deleteTexture(tex);
      gl.deleteTexture(tex2);
      gl.deleteTexture(fboTex);
      gl.deleteBuffer(vbo);
      gl.deleteBuffer(ibo);
      gl.deleteFramebuffer(fbo);
      gl.deleteRenderbuffer(rbo);
      gl.deleteVertexArray(vao);
      gl.deleteProgram(prog);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      log('Canvas 1 cleanup done\n');
    })();

    // ===================== Canvas 2: WebGL1 Basic =====================
    (() => {
      log('=== Canvas 2: WebGL1 Basic ===');
      const canvas = document.getElementById('c2');
      const gl = canvas.getContext('webgl', { alpha: false, antialias: false });
      if (!gl) { log('WebGL1 not supported'); return; }
      log('WebGL context created');

      // Simple colored triangle
      const vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, `
        attribute vec2 a_pos;
        attribute vec3 a_color;
        varying vec3 v_color;
        void main() {
          gl_Position = vec4(a_pos, 0.0, 1.0);
          v_color = a_color;
        }
      `);
      gl.compileShader(vs);

      const fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, `
        precision mediump float;
        varying vec3 v_color;
        void main() { gl_FragColor = vec4(v_color, 1.0); }
      `);
      gl.compileShader(fs);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // pos       color
         0.0,  0.7,  1, 0, 0,
        -0.7, -0.7,  0, 1, 0,
         0.7, -0.7,  0, 0, 1,
      ]), gl.STATIC_DRAW);

      const aPos = gl.getAttribLocation(prog, 'a_pos');
      const aCol = gl.getAttribLocation(prog, 'a_color');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 20, 0);
      gl.enableVertexAttribArray(aCol);
      gl.vertexAttribPointer(aCol, 3, gl.FLOAT, false, 20, 8);

      gl.clearColor(0.95, 0.95, 0.95, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      gl.flush();

      // Reads
      const px = new Uint8Array(4);
      gl.readPixels(64, 64, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
      log(`readPixels: [${px.join(', ')}]`);

      log(`isContextLost: ${gl.isContextLost()}`);
      log(`RENDERER: ${gl.getParameter(gl.RENDERER)}`);
      log(`VERSION: ${gl.getParameter(gl.VERSION)}`);

      const dataUrl = canvas.toDataURL('image/webp', 0.8);
      log(`toDataURL webp length: ${dataUrl.length}`);

      // Cleanup
      gl.deleteBuffer(buf);
      gl.deleteProgram(prog);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      log('Canvas 2 cleanup done\n');
    })();

    // ===================== Canvas 3: 2D for comparison =====================
    (() => {
      log('=== Canvas 3: 2D Context ===');
      const canvas = document.getElementById('c3');
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#336699';
      ctx.fillRect(0, 0, 200, 100);

      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.font = '24px Arial';
      ctx.fillText('Hello BotCanvas', 10, 60);

      ctx.beginPath();
      ctx.arc(170, 50, 20, 0, Math.PI * 2, false);
      ctx.fillStyle = '#ff6600';
      ctx.fill();

      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 3]);
      ctx.strokeRect(5, 5, 190, 90);

      const imgData = ctx.getImageData(0, 0, 200, 100);
      log(`getImageData: ${imgData.width}x${imgData.height}`);

      const measure = ctx.measureText('Hello BotCanvas');
      log(`measureText width: ${measure.width}`);

      const dataUrl = canvas.toDataURL('image/png');
      log(`2D toDataURL length: ${dataUrl.length}`);

      log('Canvas 3 done\n');
    })();

    log('All tests complete. Check the JSONL file.');
  </script>
</body>
</html>
