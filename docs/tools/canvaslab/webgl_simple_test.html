<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>WebGL Simple Test - BotCanvas Recording</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; background: #f5f5f5; }
    h1 { font-size: 1.4rem; }
    canvas { border: 1px solid #ccc; display: block; margin: 12px 0; background: #fff; }
    pre { background: #222; color: #ddd; padding: 12px; border-radius: 6px; font-size: 13px; max-height: 400px; overflow: auto; }
    .note { color: #666; font-size: 13px; margin-bottom: 16px; }
  </style>
</head>
<body>
  <h1>WebGL Simple Test for JSONL Recording</h1>
  <p class="note">Load this page with <code>--bot-canvas-record-file=/tmp/webgl_test.jsonl</code> to generate a recording,
    then open the JSONL file in the <a href="canvas_replay_viewer.html">Replay Viewer</a>.</p>

  <canvas id="c1" width="256" height="256"></canvas>
  <canvas id="c2" width="128" height="128"></canvas>
  <pre id="log"></pre>

  <script>
    const logEl = document.getElementById('log');
    const log = (msg) => { logEl.textContent += msg + '\n'; console.log(msg); };

    // ===================== Canvas 1: WebGL2 Full Pipeline =====================
    (() => {
      log('=== Canvas 1: WebGL2 Full Pipeline ===');
      const canvas = document.getElementById('c1');
      const gl = canvas.getContext('webgl2', { antialias: true, alpha: true });
      if (!gl) { log('WebGL2 not supported'); return; }
      log('WebGL2 context created');

      // --- Shaders ---
      const vsSource = `#version 300 es
        in vec2 a_position;
        in vec3 a_color;
        out vec3 v_color;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_color = a_color;
        }`;
      const fsSource = `#version 300 es
        precision mediump float;
        in vec3 v_color;
        out vec4 fragColor;
        void main() {
          fragColor = vec4(v_color, 1.0);
        }`;

      function createShader(type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          log('Shader error: ' + gl.getShaderInfoLog(s));
        }
        return s;
      }

      const vs = createShader(gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.validateProgram(prog);
      gl.useProgram(prog);
      log('Shaders compiled & linked');

      // --- VAO + Buffer ---
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // x, y,   r, g, b
         0.0,  0.5,  1, 0, 0,
        -0.5, -0.5,  0, 1, 0,
         0.5, -0.5,  0, 0, 1,
      ]), gl.STATIC_DRAW);

      const aPos = gl.getAttribLocation(prog, 'a_position');
      const aCol = gl.getAttribLocation(prog, 'a_color');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 20, 0);
      gl.enableVertexAttribArray(aCol);
      gl.vertexAttribPointer(aCol, 3, gl.FLOAT, false, 20, 8);
      log('Buffers set up');

      // --- Texture ---
      const tex = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      const pixels = new Uint8Array([255,0,0,255, 0,255,0,255, 0,0,255,255, 255,255,0,255]);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);
      log('Texture created');

      // --- State ---
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.viewport(0, 0, 256, 256);
      gl.clearColor(0.1, 0.1, 0.15, 1.0);
      gl.clearDepth(1.0);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.DEPTH_TEST);
      gl.colorMask(true, true, true, true);
      gl.scissor(0, 0, 256, 256);
      log('State configured');

      // --- Draw ---
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      gl.flush();
      log('Draw complete');

      // --- Read ---
      const px = new Uint8Array(4);
      gl.readPixels(128, 128, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
      log(`readPixels center: [${px.join(', ')}]`);

      const exts = gl.getSupportedExtensions();
      log(`Extensions: ${exts.length} found`);

      const attrs = gl.getContextAttributes();
      log(`Context attributes: ${JSON.stringify(attrs)}`);

      log(`Renderer: ${gl.getParameter(gl.RENDERER)}`);
      log(`Vendor: ${gl.getParameter(gl.VENDOR)}`);
      log(`Version: ${gl.getParameter(gl.VERSION)}`);
      log(`Max texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);

      // --- Cleanup ---
      gl.deleteTexture(tex);
      gl.deleteBuffer(buf);
      gl.deleteVertexArray(vao);
      gl.deleteProgram(prog);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      log('Canvas 1 cleanup done\n');
    })();

    // ===================== Canvas 2: WebGL1 Basic =====================
    (() => {
      log('=== Canvas 2: WebGL1 Basic ===');
      const canvas = document.getElementById('c2');
      const gl = canvas.getContext('webgl');
      if (!gl) { log('WebGL not supported'); return; }
      log('WebGL context created');

      // Simple triangle with WebGL1
      const vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, `
        attribute vec2 a_pos;
        void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
      `);
      gl.compileShader(vs);

      const fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, `
        precision mediump float;
        void main() { gl_FragColor = vec4(0.2, 0.6, 1.0, 1.0); }
      `);
      gl.compileShader(fs);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0.7, -0.7,-0.7, 0.7,-0.7]), gl.STATIC_DRAW);

      const aPos = gl.getAttribLocation(prog, 'a_pos');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      gl.clearColor(0.95, 0.95, 0.95, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      const px = new Uint8Array(4);
      gl.readPixels(64, 64, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, px);
      log(`readPixels: [${px.join(', ')}]`);

      const isLost = gl.isContextLost();
      log(`isContextLost: ${isLost}`);

      gl.deleteBuffer(buf);
      gl.deleteProgram(prog);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      log('Canvas 2 cleanup done\n');
    })();

    log('All WebGL tests complete. Open the JSONL in the Replay Viewer to verify WebGL support.');
  </script>
</body>
</html>
